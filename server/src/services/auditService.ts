// =============================================================================
// Audit Service - Centralized Immutable Logging
// =============================================================================
// Enterprise-grade audit trail for all marketplace actions.
// This service is APPEND-ONLY - no update or delete operations are provided.
// All significant actions are logged with actor, entity, and change details.
// =============================================================================

import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

// =============================================================================
// Types
// =============================================================================

export type ActionCategory = 'crud' | 'workflow' | 'auth' | 'admin' | 'financial';
export type ActorType = 'buyer' | 'seller' | 'approver' | 'finance' | 'system' | 'admin';
export type AuditStatus = 'success' | 'failure' | 'denied';

export interface AuditLogInput {
  entityType: string;
  entityId: string;
  entityNumber?: string;
  action: string;
  actionCategory: ActionCategory;
  actorId: string;
  actorRole: string;
  actorType: ActorType;
  previousValue?: Record<string, unknown> | null;
  newValue?: Record<string, unknown> | null;
  changedFields?: string[];
  ipAddress?: string;
  userAgent?: string;
  sessionId?: string;
  requestId?: string;
  status?: AuditStatus;
  errorMessage?: string;
  metadata?: Record<string, unknown>;
}

export interface AccessDeniedInput {
  userId: string;
  resource: string;
  action: string;
  requiredPermissions: string[];
  reason?: string;
  ipAddress?: string;
  userAgent?: string;
  requestId?: string;
}

export interface ActorContext {
  userId: string;
  role: string;
  type: ActorType;
}

export interface RequestContext {
  ipAddress?: string;
  userAgent?: string;
  requestId?: string;
  sessionId?: string;
}

export interface AuditSearchFilters {
  entityType?: string;
  entityId?: string;
  action?: string;
  actionCategory?: ActionCategory;
  actorId?: string;
  actorType?: ActorType;
  status?: AuditStatus;
  dateFrom?: Date;
  dateTo?: Date;
  limit?: number;
  offset?: number;
}

// =============================================================================
// Audit Service
// =============================================================================

export const auditService = {
  /**
   * Log an auditable action - CORE METHOD
   * This is append-only; no updates or deletes are allowed
   */
  async log(input: AuditLogInput): Promise<string> {
    try {
      const auditLog = await prisma.auditLog.create({
        data: {
          entityType: input.entityType,
          entityId: input.entityId,
          entityNumber: input.entityNumber || null,
          action: input.action,
          actionCategory: input.actionCategory,
          actorId: input.actorId,
          actorRole: input.actorRole,
          actorType: input.actorType,
          previousValue: input.previousValue ? JSON.stringify(input.previousValue) : null,
          newValue: input.newValue ? JSON.stringify(input.newValue) : null,
          changedFields: input.changedFields ? JSON.stringify(input.changedFields) : null,
          ipAddress: input.ipAddress || null,
          userAgent: input.userAgent || null,
          sessionId: input.sessionId || null,
          requestId: input.requestId || null,
          status: input.status || 'success',
          errorMessage: input.errorMessage || null,
          metadata: input.metadata ? JSON.stringify(input.metadata) : null,
          // createdAt is auto-generated by Prisma, cannot be overwritten
        },
      });

      return auditLog.id;
    } catch (error) {
      // Log to console but don't throw - audit logging should not break main flow
      console.error('Failed to write audit log:', error);
      return '';
    }
  },

  /**
   * Log access denied event
   */
  async logAccessDenied(input: AccessDeniedInput): Promise<void> {
    await this.log({
      entityType: 'access_control',
      entityId: input.resource,
      action: 'access_denied',
      actionCategory: 'auth',
      actorId: input.userId,
      actorRole: 'unknown',
      actorType: 'system',
      status: 'denied',
      errorMessage: input.reason,
      ipAddress: input.ipAddress,
      userAgent: input.userAgent,
      requestId: input.requestId,
      metadata: {
        requiredPermissions: input.requiredPermissions,
        attemptedAction: input.action,
      },
    });
  },

  /**
   * Log entity creation
   */
  async logCreate<T extends Record<string, unknown>>(
    entityType: string,
    entityId: string,
    entityNumber: string | undefined,
    newValue: T,
    actor: ActorContext,
    context?: RequestContext
  ): Promise<void> {
    await this.log({
      entityType,
      entityId,
      entityNumber,
      action: 'create',
      actionCategory: 'crud',
      actorId: actor.userId,
      actorRole: actor.role,
      actorType: actor.type,
      newValue,
      ipAddress: context?.ipAddress,
      userAgent: context?.userAgent,
      requestId: context?.requestId,
      sessionId: context?.sessionId,
    });
  },

  /**
   * Log entity update with diff
   */
  async logUpdate<T extends Record<string, unknown>>(
    entityType: string,
    entityId: string,
    entityNumber: string | undefined,
    previousValue: T,
    newValue: T,
    actor: ActorContext,
    context?: RequestContext
  ): Promise<void> {
    // Calculate changed fields
    const changedFields = Object.keys(newValue).filter(
      key => JSON.stringify(previousValue[key]) !== JSON.stringify(newValue[key])
    );

    await this.log({
      entityType,
      entityId,
      entityNumber,
      action: 'update',
      actionCategory: 'crud',
      actorId: actor.userId,
      actorRole: actor.role,
      actorType: actor.type,
      previousValue,
      newValue,
      changedFields,
      ipAddress: context?.ipAddress,
      userAgent: context?.userAgent,
      requestId: context?.requestId,
      sessionId: context?.sessionId,
    });
  },

  /**
   * Log entity deletion
   */
  async logDelete<T extends Record<string, unknown>>(
    entityType: string,
    entityId: string,
    entityNumber: string | undefined,
    deletedValue: T,
    actor: ActorContext,
    context?: RequestContext
  ): Promise<void> {
    await this.log({
      entityType,
      entityId,
      entityNumber,
      action: 'delete',
      actionCategory: 'crud',
      actorId: actor.userId,
      actorRole: actor.role,
      actorType: actor.type,
      previousValue: deletedValue,
      ipAddress: context?.ipAddress,
      userAgent: context?.userAgent,
      requestId: context?.requestId,
      sessionId: context?.sessionId,
    });
  },

  /**
   * Log workflow state transition
   */
  async logWorkflowTransition(
    entityType: string,
    entityId: string,
    entityNumber: string | undefined,
    action: string,
    fromStatus: string,
    toStatus: string,
    actor: ActorContext,
    context?: RequestContext & { metadata?: Record<string, unknown> }
  ): Promise<void> {
    await this.log({
      entityType,
      entityId,
      entityNumber,
      action,
      actionCategory: 'workflow',
      actorId: actor.userId,
      actorRole: actor.role,
      actorType: actor.type,
      previousValue: { status: fromStatus },
      newValue: { status: toStatus },
      changedFields: ['status'],
      metadata: context?.metadata,
      ipAddress: context?.ipAddress,
      userAgent: context?.userAgent,
      requestId: context?.requestId,
      sessionId: context?.sessionId,
    });
  },

  /**
   * Log financial action (payments, payouts, refunds)
   */
  async logFinancialAction(
    entityType: string,
    entityId: string,
    entityNumber: string | undefined,
    action: string,
    amount: number,
    currency: string,
    actor: ActorContext,
    context?: RequestContext & { metadata?: Record<string, unknown> }
  ): Promise<void> {
    await this.log({
      entityType,
      entityId,
      entityNumber,
      action,
      actionCategory: 'financial',
      actorId: actor.userId,
      actorRole: actor.role,
      actorType: actor.type,
      newValue: { amount, currency },
      metadata: context?.metadata,
      ipAddress: context?.ipAddress,
      userAgent: context?.userAgent,
      requestId: context?.requestId,
      sessionId: context?.sessionId,
    });
  },

  /**
   * Log authentication event
   */
  async logAuthEvent(
    action: 'login' | 'logout' | 'password_change' | 'role_assigned' | 'role_revoked',
    userId: string,
    actorType: ActorType,
    context?: RequestContext & { metadata?: Record<string, unknown> }
  ): Promise<void> {
    await this.log({
      entityType: 'user',
      entityId: userId,
      action,
      actionCategory: 'auth',
      actorId: userId,
      actorRole: actorType,
      actorType,
      metadata: context?.metadata,
      ipAddress: context?.ipAddress,
      userAgent: context?.userAgent,
      requestId: context?.requestId,
      sessionId: context?.sessionId,
    });
  },

  /**
   * Log data export action
   */
  async logExport(
    entityType: string,
    exportFormat: string,
    recordCount: number,
    actor: ActorContext,
    context?: RequestContext & { filters?: Record<string, unknown> }
  ): Promise<void> {
    await this.log({
      entityType,
      entityId: 'bulk_export',
      action: 'export',
      actionCategory: 'admin',
      actorId: actor.userId,
      actorRole: actor.role,
      actorType: actor.type,
      metadata: {
        format: exportFormat,
        recordCount,
        filters: context?.filters,
      },
      ipAddress: context?.ipAddress,
      userAgent: context?.userAgent,
      requestId: context?.requestId,
      sessionId: context?.sessionId,
    });
  },

  /**
   * Get audit trail for an entity
   */
  async getEntityAuditTrail(
    entityType: string,
    entityId: string,
    options?: { limit?: number; offset?: number }
  ): Promise<Array<{
    id: string;
    action: string;
    actionCategory: string;
    actorId: string;
    actorRole: string;
    actorType: string;
    previousValue: Record<string, unknown> | null;
    newValue: Record<string, unknown> | null;
    changedFields: string[] | null;
    status: string;
    createdAt: Date;
  }>> {
    const logs = await prisma.auditLog.findMany({
      where: { entityType, entityId },
      orderBy: { createdAt: 'desc' },
      take: options?.limit || 50,
      skip: options?.offset || 0,
      select: {
        id: true,
        action: true,
        actionCategory: true,
        actorId: true,
        actorRole: true,
        actorType: true,
        previousValue: true,
        newValue: true,
        changedFields: true,
        status: true,
        createdAt: true,
      },
    });

    return logs.map(log => ({
      ...log,
      previousValue: log.previousValue ? JSON.parse(log.previousValue) : null,
      newValue: log.newValue ? JSON.parse(log.newValue) : null,
      changedFields: log.changedFields ? JSON.parse(log.changedFields) : null,
    }));
  },

  /**
   * Get audit trail for an actor (user)
   */
  async getActorAuditTrail(
    actorId: string,
    options?: {
      limit?: number;
      offset?: number;
      entityType?: string;
      dateFrom?: Date;
      dateTo?: Date;
    }
  ): Promise<Array<{
    id: string;
    entityType: string;
    entityId: string;
    entityNumber: string | null;
    action: string;
    status: string;
    createdAt: Date;
  }>> {
    const where: Record<string, unknown> = { actorId };

    if (options?.entityType) {
      where.entityType = options.entityType;
    }
    if (options?.dateFrom || options?.dateTo) {
      where.createdAt = {};
      if (options?.dateFrom) (where.createdAt as Record<string, Date>).gte = options.dateFrom;
      if (options?.dateTo) (where.createdAt as Record<string, Date>).lte = options.dateTo;
    }

    const logs = await prisma.auditLog.findMany({
      where,
      orderBy: { createdAt: 'desc' },
      take: options?.limit || 50,
      skip: options?.offset || 0,
      select: {
        id: true,
        entityType: true,
        entityId: true,
        entityNumber: true,
        action: true,
        status: true,
        createdAt: true,
      },
    });

    return logs;
  },

  /**
   * Search audit logs with filters
   */
  async searchAuditLogs(filters: AuditSearchFilters): Promise<{
    logs: Array<{
      id: string;
      entityType: string;
      entityId: string;
      entityNumber: string | null;
      action: string;
      actionCategory: string;
      actorId: string;
      actorRole: string;
      actorType: string;
      status: string;
      createdAt: Date;
    }>;
    total: number;
  }> {
    const where: Record<string, unknown> = {};

    if (filters.entityType) where.entityType = filters.entityType;
    if (filters.entityId) where.entityId = filters.entityId;
    if (filters.action) where.action = filters.action;
    if (filters.actionCategory) where.actionCategory = filters.actionCategory;
    if (filters.actorId) where.actorId = filters.actorId;
    if (filters.actorType) where.actorType = filters.actorType;
    if (filters.status) where.status = filters.status;
    if (filters.dateFrom || filters.dateTo) {
      where.createdAt = {};
      if (filters.dateFrom) (where.createdAt as Record<string, Date>).gte = filters.dateFrom;
      if (filters.dateTo) (where.createdAt as Record<string, Date>).lte = filters.dateTo;
    }

    const [logs, total] = await Promise.all([
      prisma.auditLog.findMany({
        where,
        orderBy: { createdAt: 'desc' },
        take: filters.limit || 50,
        skip: filters.offset || 0,
        select: {
          id: true,
          entityType: true,
          entityId: true,
          entityNumber: true,
          action: true,
          actionCategory: true,
          actorId: true,
          actorRole: true,
          actorType: true,
          status: true,
          createdAt: true,
        },
      }),
      prisma.auditLog.count({ where }),
    ]);

    return { logs, total };
  },

  /**
   * Get audit statistics for a time period
   */
  async getAuditStats(
    dateFrom: Date,
    dateTo: Date
  ): Promise<{
    totalActions: number;
    byCategory: Record<string, number>;
    byStatus: Record<string, number>;
    byEntityType: Record<string, number>;
  }> {
    const logs = await prisma.auditLog.findMany({
      where: {
        createdAt: {
          gte: dateFrom,
          lte: dateTo,
        },
      },
      select: {
        actionCategory: true,
        status: true,
        entityType: true,
      },
    });

    const byCategory: Record<string, number> = {};
    const byStatus: Record<string, number> = {};
    const byEntityType: Record<string, number> = {};

    for (const log of logs) {
      byCategory[log.actionCategory] = (byCategory[log.actionCategory] || 0) + 1;
      byStatus[log.status] = (byStatus[log.status] || 0) + 1;
      byEntityType[log.entityType] = (byEntityType[log.entityType] || 0) + 1;
    }

    return {
      totalActions: logs.length,
      byCategory,
      byStatus,
      byEntityType,
    };
  },
};

export default auditService;
