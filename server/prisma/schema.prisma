// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// User System (SaaS)
model User {
  id        String   @id // Will store the Auth Provider ID (e.g. Clerk user_id)
  email     String   @unique
  name      String?
  avatarUrl String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Multi-tenancy
  workspaceId String?
  workspace   Workspace? @relation(fields: [workspaceId], references: [id])

  // Relations
  procurementRequests ProcurementRequest[]
  rfqs               RFQ[]
  orders             Order[]
  boards             Board[]
  rooms              Room[]
  emailAccounts      EmailAccount[]
  vaultItems         VaultItem[]
  activities         Activity[]
  
  // Pivot for many-to-many if needed later, but simple 1-workspace for now
}

model Activity {
  id          String   @id @default(uuid())
  userId      String
  workspaceId String?
  boardId     String?
  type        String   // e.g., "TASK_CREATED", "BOARD_CREATED", etc.
  content     String   // Display message
  metadata    String?  // JSON string for extra data (boardId, taskId, etc.)
  createdAt   DateTime @default(now())

  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  workspace Workspace? @relation(fields: [workspaceId], references: [id], onDelete: SetNull)
  board     Board?     @relation(fields: [boardId], references: [id], onDelete: SetNull)
}

model Workspace {
  id        String   @id @default(uuid())
  name      String
  icon      String?
  color     String?
  ownerId   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  users       User[]
  invitations Invitation[]
  boards      Board[]
  activities  Activity[]
}

model Invitation {
  id        String   @id @default(uuid())
  email     String
  token     String   @unique
  status    String   @default("PENDING") // PENDING, ACCEPTED, EXPIRED
  workspaceId String
  workspace   Workspace @relation(fields: [workspaceId], references: [id])
  createdAt DateTime @default(now())
  expiresAt DateTime
}

// Procurement System
model ProcurementRequest {
  id             String    @id
  userId         String    // SaaS Multi-tenancy
  name           String
  date           String 
  department     String
  warehouse      String?
  relatedTo      String?
  status         String    @default("Pending")
  priority       String    @default("Normal")
  isUrgent       Boolean   @default(false)
  approvalStatus String    @default("Pending")
  rfqSent        Boolean   @default(false)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  user  User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  items RequestItem[]
  rfqs  RFQ[]
}

model RequestItem {
  id            String  @id @default(uuid())
  requestId     String
  itemCode      String
  description   String
  quantity      Float
  dueDate       String?
  unitPrice     Float?
  
  request ProcurementRequest @relation(fields: [requestId], references: [id], onDelete: Cascade)
}

model RFQ {
  id          String   @id
  userId      String   // SaaS Multi-tenancy
  requestId   String?
  date        String
  department  String
  warehouse   String?
  supplier    String
  value       Float    @default(0)
  dueDate     String?
  status      String   @default("Open")
  createdDate String
  relatedTo   String?
  sentToOrder Boolean  @default(false)
  orderId     String?
  
  unitPrice   Float?
  quantity    Float?
  vatAmount   Float?
  totalExVat  Float?

  user    User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  request ProcurementRequest? @relation(fields: [requestId], references: [id])
  items   RFQItem[]
  Order   Order[]
}

model RFQItem {
  id          String @id @default(uuid())
  rfqId       String
  itemCode    String
  description String
  quantity    Float
  dueDate     String?
  unitPrice   Float?

  rfq RFQ @relation(fields: [rfqId], references: [id], onDelete: Cascade)
}

model Order {
  id          String   @id
  userId      String   // SaaS Multi-tenancy
  rfqId       String?
  requestId   String?
  supplier    String
  department  String
  warehouse   String?
  date        String
  dueDate     String?
  totalValue  Float
  priority    String?
  status      String   @default("Open")
  approvals   String?
  relatedTo   String?
  
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  rfq   RFQ?  @relation(fields: [rfqId], references: [id])
  items OrderItem[]
}

model OrderItem {
  id          String @id @default(uuid())
  orderId     String
  itemCode    String
  description String
  quantity    Float
  dueDate     String?
  unitPrice   Float?

  order Order @relation(fields: [orderId], references: [id], onDelete: Cascade)
}

// Board System
model Board {
  id             String   @id @default(uuid())
  userId         String   // SaaS Multi-tenancy
  name           String   
  icon           String?
  description    String?
  availableViews String?  
  pinnedViews    String?  
  columns        String?  
  defaultView    String?
  tasks          String   @default("[]") // Storing tasks as JSON for flexibility
  type           String   @default("project") // "project" or "discussion"
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  user  User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  workspaceId String?
  workspace   Workspace? @relation(fields: [workspaceId], references: [id]) // Optional for now to support private boards? Or enforce it? Let's make it optional for migration safety but intended for use.
  
  cards      Card[]
  threads    Thread[]
  activities Activity[]
}

model Thread {
  id        String   @id @default(uuid())
  boardId   String
  title     String
  preview   String?
  updatedAt DateTime @updatedAt
  messages  String   @default("[]") // JSON string of Message[]
  priority  String?
  dueDate   DateTime?
  
  board     Board    @relation(fields: [boardId], references: [id], onDelete: Cascade)
}

model Card {
  id          String   @id @default(uuid())
  boardId     String
  title       String
  description String?
  columnId    String?
  board       Board    @relation(fields: [boardId], references: [id], onDelete: Cascade)
}

// Room/Table System
model Room {
  id        String   @id @default(uuid())
  userId    String   // SaaS Multi-tenancy
  name      String
  type      String   @default("table")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  user User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  rows Row[]
}

model Row {
  id        String   @id @default(uuid())
  roomId    String
  // Storing dynamic row data as JSON string
  content   String   @default("{}") 
  
  room      Room     @relation(fields: [roomId], references: [id], onDelete: Cascade)
}

model ColumnStore {
  id        String @id @default(uuid())
  roomId    String 
  columns   String // JSON string of Column[] definitions
}

// Email Integration
model EmailAccount {
  id           String   @id @default(uuid())
  userId       String   // SaaS Multi-tenancy
  provider     String   
  email        String
  accessToken  String
  refreshToken String
  tokenExpiry  DateTime
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// Vault System
model VaultItem {
  id          String   @id @default(uuid())
  userId      String   // SaaS Multi-tenancy
  title       String
  type        String   // folder, file, note, weblink
  subtitle    String?
  content     String?  // For notes or text content
  metadata    String?  // JSON string for file size, mimeType, dimensions, etc.
  isFavorite  Boolean  @default(false)
  folderId    String?  // Parent folder ID
  color       String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user    User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  parent  VaultItem? @relation("FolderItems", fields: [folderId], references: [id], onDelete: Cascade)
  children VaultItem[] @relation("FolderItems")
}
