// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// Procurement System
model ProcurementRequest {
  id             String    @id
  name           String
  date           String // Storing dates as string for simplicity to match frontend 'YYYY-MM-DD'
  department     String
  warehouse      String?
  relatedTo      String?
  status         String    @default("Pending") // Pending, Approved, Rejected
  priority       String    @default("Normal")
  isUrgent       Boolean   @default(false)
  approvalStatus String    @default("Pending")
  rfqSent        Boolean   @default(false)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  items RequestItem[]
  rfqs  RFQ[]
}

model RequestItem {
  id            String  @id @default(uuid())
  requestId     String
  itemCode      String
  description   String
  quantity      Float
  dueDate       String?
  unitPrice     Float?
  
  request ProcurementRequest @relation(fields: [requestId], references: [id], onDelete: Cascade)
}

model RFQ {
  id          String   @id
  requestId   String?
  date        String
  department  String
  warehouse   String?
  supplier    String
  value       Float    @default(0)
  dueDate     String?
  status      String   @default("Open") // Open, Sent to PO, Closed
  createdDate String
  relatedTo   String?
  sentToOrder Boolean  @default(false)
  orderId     String?
  
  // Aggregate fields often stored on the parent in the JSON, but can be computed. 
  // We keep them fore compatibility with frontend which reads them directly
  unitPrice   Float?
  quantity    Float?
  vatAmount   Float?
  totalExVat  Float?

  request ProcurementRequest? @relation(fields: [requestId], references: [id])
  items   RFQItem[]
  Order   Order[]
}

model RFQItem {
  id          String @id @default(uuid())
  rfqId       String
  itemCode    String
  description String
  quantity    Float
  dueDate     String?
  unitPrice   Float?

  rfq RFQ @relation(fields: [rfqId], references: [id], onDelete: Cascade)
}

model Order {
  id          String   @id
  rfqId       String?
  requestId   String?
  supplier    String
  department  String
  warehouse   String?
  date        String
  dueDate     String?
  totalValue  Float
  priority    String?
  status      String   @default("Open")
  approvals   String?
  relatedTo   String?
  
  rfq   RFQ? @relation(fields: [rfqId], references: [id])
  items OrderItem[]
}

model OrderItem {
  id          String @id @default(uuid())
  orderId     String
  itemCode    String
  description String
  quantity    Float
  dueDate     String?
  unitPrice   Float?

  order Order @relation(fields: [orderId], references: [id], onDelete: Cascade)
}

// Board System
model Board {
  id             String   @id @default(uuid())
  name           String   // Changed from title to name to match frontend
  description    String?
  availableViews String?  // JSON string
  pinnedViews    String?  // JSON string
  defaultView    String?
  cards          Card[]
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
}

model Card {
  id          String   @id @default(uuid())
  boardId     String
  title       String
  description String?
  columnId    String?
  board       Board    @relation(fields: [boardId], references: [id], onDelete: Cascade)
}

// Room/Table System
model Room {
  id        String   @id @default(uuid())
  name      String
  type      String   @default("table")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  rows      Row[]
}

model Row {
  id        String   @id @default(uuid())
  roomId    String
  data      String   // Storing dynamic row data as JSON string (Prisma 5+ SQLite doesn't strictly enforce JSON type on string field but usually we use @map? No, standard String is fine for JSON.stringify)
                   // actually, we can try to use standard fields if we know them, but for generic table it varies.
                   // Let's use `data` field to store the entire row object stringified to overlap with json-server behavior?
                   // No, roomService sends specific fields.
                   // Wait, json-server just stores whatever you send.
                   // To mimic this in SQL, we either need a JSON column or specific columns.
                   // SQLite supports JSON.
  
  room      Room     @relation(fields: [roomId], references: [id], onDelete: Cascade)
  
  // If we want to be "Relational", we should have fixed columns. 
  // But the frontend allows adding columns dynamically.
  // So a JSON content column is the only way to match json-server flexibility without code changes.
  content   String   @default("{}") // JSON string of the row data
}

model ColumnStore {
  id        String @id @default(uuid())
  roomId    String 
  columns   String // JSON string of Column[] definitions
}
